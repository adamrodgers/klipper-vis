<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klipper Pin Mapper</title>
    <style>
        :root {
            --bg-primary: #0f1114;
            --bg-secondary: #16181d;
            --bg-tertiary: #1e2128;
            --bg-card: #1a1d23;
            --accent: #5cdbab;
            --accent-dim: #3d9476;
            --accent-glow: rgba(92, 219, 171, 0.12);
            --success: #5cdbab;
            --warning: #e5c07b;
            --error: #e06c75;
            --info: #61afef;
            --text-primary: #d4d7dd;
            --text-secondary: #878c96;
            --text-muted: #4d525c;
            --border-color: #2a2e38;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
            font-size: 14px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0 1.25rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1.25rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 { font-size: 1.25rem; font-weight: 600; color: var(--text-primary); }
        .subtitle { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem; }

        .board-selector {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .board-selector label { font-size: 0.7rem; color: var(--text-secondary); }

        select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            min-width: 200px;
        }

        select:focus { outline: none; border-color: var(--accent); }

        .detected-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.6rem;
            background: var(--accent-glow);
            border: 1px solid var(--accent-dim);
            border-radius: 3px;
            font-size: 0.65rem;
            color: var(--accent);
        }

        .detected-badge.low-confidence {
            background: rgba(219, 197, 92, 0.1);
            border-color: rgba(219, 197, 92, 0.4);
            color: var(--warning);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 1.25rem;
        }

        @media (max-width: 1200px) {
            .main-layout { grid-template-columns: 1fr; }
        }

        .input-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .card-header {
            padding: 0.6rem 0.85rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .card-body { padding: 0.85rem; }

        textarea {
            width: 100%;
            height: 260px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.65rem;
            color: var(--text-primary);
            font-family: 'SF Mono', Consolas, Monaco, monospace;
            font-size: 0.75rem;
            line-height: 1.5;
            resize: vertical;
        }

        textarea:focus { outline: none; border-color: var(--accent); }

        .btn-row { display: flex; gap: 0.5rem; margin-top: 0.65rem; }

        button {
            padding: 0.55rem 0.85rem;
            border: none;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-primary { background: var(--accent); color: var(--bg-primary); flex: 1; }
        .btn-primary:hover { background: #7ae5c0; }
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            flex: 1;
        }
        .btn-secondary:hover { background: var(--border-color); color: var(--text-primary); }
        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.6rem;
            flex: none;
        }
        .btn-copy {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border: 1px solid var(--border-color);
        }
        .btn-copy:hover { color: var(--accent); border-color: var(--accent); }
        .btn-copy.copied { color: var(--success); border-color: var(--success); }

        .board-container {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 1.25rem;
            min-height: calc(100vh - 280px);
        }

        .board-outline {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            position: relative;
            padding: 1rem;
        }

        .board-label {
            position: absolute;
            top: -10px;
            left: 16px;
            background: var(--bg-secondary);
            padding: 0.2rem 0.6rem;
            border-radius: 3px;
            font-size: 0.65rem;
            color: var(--text-muted);
            border: 1px solid var(--border-color);
        }

        .driver-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.65rem;
        }

        @media (max-width: 1000px) {
            .driver-slots { grid-template-columns: repeat(2, 1fr); }
        }

        .driver-slot {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.55rem;
            position: relative;
            transition: all 0.15s;
        }

        .driver-slot.active {
            border-color: var(--accent-dim);
            background: rgba(92, 219, 171, 0.03);
        }

        .driver-slot.has-issue {
            border-color: var(--error);
            background: rgba(219, 107, 92, 0.05);
        }

        .driver-slot.external-mcu {
            border-color: var(--info);
            background: rgba(97, 175, 239, 0.05);
        }

        .slot-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            gap: 0.25rem;
        }

        .slot-id { font-size: 0.6rem; color: var(--text-muted); }

        .slot-driver {
            font-size: 0.55rem;
            padding: 0.1rem 0.3rem;
            background: var(--bg-primary);
            border-radius: 2px;
            color: var(--warning);
        }

        .slot-current {
            font-size: 0.5rem;
            padding: 0.1rem 0.25rem;
            background: var(--bg-primary);
            border-radius: 2px;
            color: var(--text-muted);
        }

        .slot-current.high { color: var(--error); }

        .slot-motor {
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.15rem;
            color: var(--text-primary);
        }

        .slot-motor.empty {
            color: var(--text-muted);
            font-weight: 400;
            font-size: 0.65rem;
        }

        .slot-motor-info {
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .slot-pins {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.15rem;
            font-size: 0.55rem;
        }

        .pin-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.12rem 0.2rem;
            background: var(--bg-primary);
            border-radius: 2px;
        }

        .pin-label { color: var(--text-muted); }
        .pin-value { color: var(--text-secondary); font-family: 'SF Mono', Consolas, monospace; }

        .pin-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-left: 3px;
            flex-shrink: 0;
        }

        .pin-status.ok { background: var(--success); }
        .pin-status.warn { background: var(--error); }

        .issues-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .issue-item {
            padding: 0.5rem;
            background: var(--bg-primary);
            border-radius: 4px;
            margin-bottom: 0.4rem;
            border-left: 2px solid var(--error);
            font-size: 0.68rem;
        }

        .issue-item.warning { border-left-color: var(--warning); }
        .issue-item.info { border-left-color: var(--info); }

        .issue-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .issue-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.1rem;
        }

        .issue-detail { color: var(--text-secondary); }

        .issue-fix {
            margin-top: 0.3rem;
            padding: 0.25rem 0.4rem;
            background: var(--bg-tertiary);
            border-radius: 3px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.7rem;
            color: var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .issue-fix code { flex: 1; }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.68rem;
        }

        .comparison-table th {
            position: sticky;
            top: 0;
            background: var(--bg-tertiary);
            padding: 0.45rem 0.55rem;
            text-align: left;
            font-weight: 500;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
            text-transform: uppercase;
            font-size: 0.6rem;
            letter-spacing: 0.3px;
        }

        .comparison-table td {
            padding: 0.4rem 0.55rem;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table tr:hover td { background: var(--bg-tertiary); }
        .comparison-table tr.mismatch-row td { background: rgba(219, 107, 92, 0.06); }

        .pin-badge {
            display: inline-block;
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
            font-size: 0.58rem;
            font-weight: 500;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .status-chip { font-size: 0.6rem; font-weight: 500; }
        .status-chip.match { color: var(--success); }
        .status-chip.mismatch { color: var(--error); }

        .stats-row {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .stat-chip {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .stat-chip .value { font-weight: 600; color: var(--text-primary); }
        .stat-chip.awd { background: rgba(97, 175, 239, 0.1); color: var(--info); }
        .stat-chip.awd .value { color: var(--info); }

        .tabs {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.85rem;
        }

        .tab {
            padding: 0.4rem 0.85rem;
            font-size: 0.68rem;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .tab:hover { background: var(--bg-tertiary); color: var(--text-secondary); }
        .tab.active { background: var(--accent-dim); color: var(--bg-primary); }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
            text-align: center;
        }

        .table-container {
            max-height: calc(100vh - 280px);
            min-height: 400px;
            overflow-y: auto;
        }

        .detection-debug { font-size: 0.63rem; }

        .detection-score {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .detection-score:last-child { border-bottom: none; }
        .detection-score .board-name { color: var(--text-secondary); }
        .detection-score .score { color: var(--text-muted); }

        .detection-score.winner {
            background: var(--accent-glow);
            margin: 0 -0.5rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
        }

        .detection-score.winner .score { color: var(--accent); font-weight: 600; }

        .no-issues {
            padding: 0.75rem;
            background: var(--accent-glow);
            border-radius: 4px;
            color: var(--accent);
            font-size: 0.7rem;
        }

        .mcu-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px dashed var(--border-color);
        }

        .mcu-section-label {
            font-size: 0.65rem;
            color: var(--info);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mcu-section-label::before {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        .mcu-section-label::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        .external-motors {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.65rem;
        }

        @media (max-width: 1000px) {
            .external-motors { grid-template-columns: repeat(2, 1fr); }
        }

        .export-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .export-textarea {
            width: 100%;
            height: 150px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            color: var(--accent);
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.65rem;
            resize: vertical;
            margin-top: 0.5rem;
        }

        .endstop-section-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.75rem;
            margin-bottom: 0.35rem;
        }

        .endstop-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .endstop-item {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0.4rem;
            background: var(--bg-primary);
            border-radius: 3px;
            font-size: 0.65rem;
        }

        .endstop-item .motor { color: var(--text-primary); }
        .endstop-item .type { color: var(--text-muted); }
        .endstop-item .type.sensorless { color: var(--info); }
        .endstop-item .type.probe { color: var(--accent); }
        .endstop-item .type.physical { color: var(--warning); }

        ::-webkit-scrollbar { width: 5px; height: 5px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Klipper Pin Mapper</h1>
                <div class="subtitle">Validate stepper pin assignments against board pinouts</div>
            </div>
            <div class="board-selector">
                <label>Board:</label>
                <select id="boardSelect" onchange="onBoardChange()">
                    <option value="auto">Auto-detect</option>
                    <optgroup label="BTT Octopus Pro">
                        <option value="octopus_pro_v1.0">Octopus Pro v1.0</option>
                        <option value="octopus_pro_v1.1">Octopus Pro v1.1</option>
                    </optgroup>
                    <optgroup label="BTT Octopus">
                        <option value="octopus_v1.1">Octopus v1.1</option>
                    </optgroup>
                    <optgroup label="BTT Kraken">
                        <option value="kraken">Kraken</option>
                    </optgroup>
                    <optgroup label="BTT Manta M8P">
                        <option value="manta_m8p_v1">Manta M8P v1.0/1.1</option>
                        <option value="manta_m8p_v2">Manta M8P v2.0</option>
                    </optgroup>
                </select>
                <span class="detected-badge" id="detectedBadge" style="display: none;">
                    <span id="detectedText">Detected</span>
                </span>
            </div>
        </header>

        <div class="main-layout">
            <div class="input-panel">
                <div class="card">
                    <div class="card-header">
                        <span class="card-title">Configuration</span>
                    </div>
                    <div class="card-body">
                        <textarea id="configInput" placeholder="Paste your printer.cfg stepper and TMC sections here..."></textarea>
                        <div class="btn-row">
                            <button class="btn-primary" onclick="parseConfig()">Map Pins</button>
                            <button class="btn-secondary" onclick="clearAll()">Clear</button>
                        </div>
                    </div>
                </div>

                <div class="card" id="detectionCard" style="display: none;">
                    <div class="card-header">
                        <span class="card-title">Detection</span>
                    </div>
                    <div class="card-body">
                        <div class="detection-debug" id="detectionDebug"></div>
                    </div>
                </div>

                <div class="card" id="issuesCard" style="display: none;">
                    <div class="card-header">
                        <span class="card-title">Issues</span>
                        <span id="issueCount" style="font-size: 0.65rem; color: var(--error);"></span>
                    </div>
                    <div class="card-body">
                        <div class="issues-list" id="issuesList"></div>
                        <div class="export-section" id="exportSection" style="display: none;">
                            <button class="btn-secondary btn-small" onclick="toggleExport()">Export Fixes</button>
                            <textarea class="export-textarea" id="exportTextarea" style="display: none;" readonly></textarea>
                        </div>
                    </div>
                </div>

                <div class="card" id="statsCard" style="display: none;">
                    <div class="card-header">
                        <span class="card-title">Summary</span>
                    </div>
                    <div class="card-body">
                        <div class="stats-row" id="statsRow"></div>
                        <div class="endstop-section-label" id="endstopLabel" style="display: none;">Endstop Config</div>
                        <div class="endstop-list" id="endstopList"></div>
                    </div>
                </div>
            </div>

            <div class="board-viz">
                <div class="card">
                    <div class="card-header">
                        <span class="card-title" id="vizTitle">Board View</span>
                    </div>
                    <div class="card-body">
                        <div class="tabs">
                            <div class="tab active" onclick="switchTab('board')">Visual</div>
                            <div class="tab" onclick="switchTab('table')">Table</div>
                        </div>

                        <div class="tab-content active" id="boardTab">
                            <div class="board-container" id="boardContainer">
                                <div class="empty-state" id="emptyState">
                                    <p>Paste configuration and click "Map Pins"</p>
                                </div>
                                <div id="boardViz" style="display: none;"></div>
                            </div>
                        </div>

                        <div class="tab-content" id="tableTab">
                            <div class="table-container" id="tableContainer">
                                <div class="empty-state">
                                    <p>No data</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Typical sense resistor values by driver type
        const SENSE_RESISTORS = {
            'TMC2209': 0.110,
            'TMC2226': 0.110,
            'TMC2208': 0.110,
            'TMC2225': 0.110,
            'TMC5160': 0.075,
            'TMC5161': 0.075,
            'TMC2130': 0.110,
            'TMC2160': 0.075,
        };

        // Max recommended current by driver
        const MAX_CURRENT = {
            'TMC2209': 2.0,
            'TMC2226': 2.0,
            'TMC2208': 1.4,
            'TMC2225': 1.4,
            'TMC5160': 3.0,
            'TMC5161': 3.0,
            'TMC2130': 1.2,
            'TMC2160': 2.5,
        };

        const BOARDS = {
            'octopus_pro_v1.0': {
                name: 'BTT Octopus Pro v1.0',
                mcu: 'STM32F446/F429',
                driverCount: 8,
                drivers: [
                    { id: 'DRIVER0', step: 'PF13', dir: 'PF12', enable: 'PF14', uart: 'PC4', cs: 'PC4', diag: 'PG6' },
                    { id: 'DRIVER1', step: 'PG0', dir: 'PG1', enable: 'PF15', uart: 'PD11', cs: 'PD11', diag: 'PG9' },
                    { id: 'DRIVER2', step: 'PF11', dir: 'PG3', enable: 'PG5', uart: 'PC6', cs: 'PC6', diag: 'PG10' },
                    { id: 'DRIVER3', step: 'PG4', dir: 'PC1', enable: 'PA0', uart: 'PC7', cs: 'PC7', diag: 'PG11' },
                    { id: 'DRIVER4', step: 'PF9', dir: 'PF10', enable: 'PG2', uart: 'PF2', cs: 'PF2', diag: 'PG12' },
                    { id: 'DRIVER5', step: 'PC13', dir: 'PF0', enable: 'PF1', uart: 'PE4', cs: 'PE4', diag: 'PG13' },
                    { id: 'DRIVER6', step: 'PE2', dir: 'PE3', enable: 'PD4', uart: 'PE1', cs: 'PE1', diag: 'PG14' },
                    { id: 'DRIVER7', step: 'PE6', dir: 'PA14', enable: 'PE0', uart: 'PD3', cs: 'PD3', diag: 'PG15' }
                ],
                signaturePins: ['PF13', 'PF11', 'PF9', 'PG0', 'PG4', 'PC13'],
                requiredCombos: [{ step: 'PF13', dir: 'PF12' }, { step: 'PF11', dir: 'PG3' }],
            },
            'octopus_pro_v1.1': {
                name: 'BTT Octopus Pro v1.1',
                mcu: 'STM32F446/F429/H723',
                driverCount: 8,
                drivers: [
                    { id: 'DRIVER0', step: 'PF13', dir: 'PF12', enable: 'PF14', uart: 'PC4', cs: 'PC4', diag: 'PG6' },
                    { id: 'DRIVER1', step: 'PG0', dir: 'PG1', enable: 'PF15', uart: 'PD11', cs: 'PD11', diag: 'PG9' },
                    { id: 'DRIVER2', step: 'PF11', dir: 'PG3', enable: 'PG5', uart: 'PC6', cs: 'PC6', diag: 'PG10' },
                    { id: 'DRIVER3', step: 'PG4', dir: 'PC1', enable: 'PA2', uart: 'PC7', cs: 'PC7', diag: 'PG11' },
                    { id: 'DRIVER4', step: 'PF9', dir: 'PF10', enable: 'PG2', uart: 'PF2', cs: 'PF2', diag: 'PG12' },
                    { id: 'DRIVER5', step: 'PC13', dir: 'PF0', enable: 'PF1', uart: 'PE4', cs: 'PE4', diag: 'PG13' },
                    { id: 'DRIVER6', step: 'PE2', dir: 'PE3', enable: 'PD4', uart: 'PE1', cs: 'PE1', diag: 'PG14' },
                    { id: 'DRIVER7', step: 'PE6', dir: 'PA14', enable: 'PE0', uart: 'PD3', cs: 'PD3', diag: 'PG15' }
                ],
                signaturePins: ['PF13', 'PF11', 'PF9', 'PG0', 'PG4', 'PC13'],
                requiredCombos: [{ step: 'PF13', dir: 'PF12' }, { step: 'PF11', dir: 'PG3' }],
            },
            'octopus_v1.1': {
                name: 'BTT Octopus v1.1',
                mcu: 'STM32F446/F429',
                driverCount: 8,
                drivers: [
                    { id: 'DRIVER0', step: 'PF13', dir: 'PF12', enable: 'PF14', uart: 'PC4', diag: 'PG6' },
                    { id: 'DRIVER1', step: 'PG0', dir: 'PG1', enable: 'PF15', uart: 'PD11', diag: 'PG9' },
                    { id: 'DRIVER2', step: 'PF11', dir: 'PG3', enable: 'PG5', uart: 'PC6', diag: 'PG10' },
                    { id: 'DRIVER3', step: 'PG4', dir: 'PC1', enable: 'PA0', uart: 'PC7', diag: 'PG11' },
                    { id: 'DRIVER4', step: 'PF9', dir: 'PF10', enable: 'PG2', uart: 'PF2', diag: 'PG12' },
                    { id: 'DRIVER5', step: 'PC13', dir: 'PF0', enable: 'PF1', uart: 'PE4', diag: 'PG13' },
                    { id: 'DRIVER6', step: 'PE2', dir: 'PE3', enable: 'PD4', uart: 'PE1', diag: 'PG14' },
                    { id: 'DRIVER7', step: 'PE6', dir: 'PA14', enable: 'PE0', uart: 'PD3', diag: 'PG15' }
                ],
                signaturePins: ['PF13', 'PF11', 'PF9'],
                requiredCombos: [{ step: 'PF13', dir: 'PF12' }],
            },
            'kraken': {
                name: 'BTT Kraken',
                mcu: 'STM32H723',
                driverCount: 8,
                drivers: [
                    { id: 'M1', step: 'PC14', dir: 'PC13', enable: 'PE6', uart: 'PD6', cs: 'PD6', diag: 'PC15' },
                    { id: 'M2', step: 'PE5', dir: 'PE4', enable: 'PE3', uart: 'PD5', cs: 'PD5', diag: 'PF0' },
                    { id: 'M3', step: 'PE2', dir: 'PE1', enable: 'PE0', uart: 'PD4', cs: 'PD4', diag: 'PF1' },
                    { id: 'M4', step: 'PB9', dir: 'PB8', enable: 'PB7', uart: 'PD3', cs: 'PD3', diag: 'PF2' },
                    { id: 'M5', step: 'PG9', dir: 'PG10', enable: 'PG13', uart: 'PD2', cs: 'PD2', diag: 'PF3' },
                    { id: 'M6', step: 'PG11', dir: 'PD7', enable: 'PG12', uart: 'PA15', cs: 'PA15', diag: 'PF4' },
                    { id: 'M7', step: 'PB4', dir: 'PB3', enable: 'PB5', uart: 'PA9', cs: 'PA9', diag: 'PF10' },
                    { id: 'M8', step: 'PG15', dir: 'PB6', enable: 'PG14', uart: 'PA10', cs: 'PA10', diag: 'PC0' }
                ],
                signaturePins: ['PC14', 'PE5', 'PB9', 'PG9', 'PG11', 'PB4', 'PG15'],
                requiredCombos: [
                    { step: 'PC14', dir: 'PC13' }, { step: 'PE5', dir: 'PE4' },
                    { step: 'PB9', dir: 'PB8' }, { step: 'PG9', dir: 'PG10' }, { step: 'PG11', dir: 'PD7' }
                ],
                uniqueIdentifiers: ['PC14', 'PE5', 'PB9'],
            },
            'manta_m8p_v1': {
                name: 'BTT Manta M8P v1.0/1.1',
                mcu: 'STM32G0B1',
                driverCount: 8,
                drivers: [
                    { id: 'M1', step: 'PE2', dir: 'PB4', enable: 'PC11', uart: 'PC10', cs: 'PC10', diag: 'PF3' },
                    { id: 'M2', step: 'PF12', dir: 'PF11', enable: 'PB3', uart: 'PF13', cs: 'PF13', diag: 'PF4' },
                    { id: 'M3', step: 'PD7', dir: 'PD6', enable: 'PF10', uart: 'PF9', cs: 'PF9', diag: 'PF5' },
                    { id: 'M4', step: 'PD3', dir: 'PD2', enable: 'PD5', uart: 'PD4', cs: 'PD4', diag: 'PC0' },
                    { id: 'M5', step: 'PC9', dir: 'PC8', enable: 'PD1', uart: 'PD0', cs: 'PD0', diag: 'PC1' },
                    { id: 'M6', step: 'PA10', dir: 'PA14', enable: 'PA15', uart: 'PF8', cs: 'PF8', diag: 'PC2' },
                    { id: 'M7', step: 'PD11', dir: 'PD9', enable: 'PD15', uart: 'PD14', cs: 'PD14', diag: 'PC3' },
                    { id: 'M8', step: 'PD8', dir: 'PC6', enable: 'PD10', uart: 'PD13', cs: 'PD13', diag: 'PA0' }
                ],
                signaturePins: ['PF12', 'PD7', 'PC9', 'PD11', 'PD8'],
                excludePins: ['PC14', 'PE5', 'PB9'],
                requiredCombos: [{ step: 'PF12', dir: 'PF11' }, { step: 'PC9', dir: 'PC8' }],
                uniqueIdentifiers: ['PF12', 'PC9', 'PD11', 'PD8'],
            },
            'manta_m8p_v2': {
                name: 'BTT Manta M8P v2.0',
                mcu: 'STM32H723',
                driverCount: 8,
                drivers: [
                    { id: 'M1', step: 'PE6', dir: 'PE5', enable: 'PC14', uart: 'PC13', cs: 'PC13', diag: 'PF0' },
                    { id: 'M2', step: 'PE2', dir: 'PE1', enable: 'PE4', uart: 'PE3', cs: 'PE3', diag: 'PF1' },
                    { id: 'M3', step: 'PB8', dir: 'PB7', enable: 'PE0', uart: 'PB9', cs: 'PB9', diag: 'PF2' },
                    { id: 'M4', step: 'PB4', dir: 'PB3', enable: 'PB6', uart: 'PB5', cs: 'PB5', diag: 'PF3' },
                    { id: 'M5', step: 'PG13', dir: 'PG12', enable: 'PG15', uart: 'PG14', cs: 'PG14', diag: 'PF4' },
                    { id: 'M6', step: 'PG9', dir: 'PD7', enable: 'PG10', uart: 'PG11', cs: 'PG11', diag: 'PF5' },
                    { id: 'M7', step: 'PD4', dir: 'PD3', enable: 'PD6', uart: 'PD5', cs: 'PD5', diag: 'PF6' },
                    { id: 'M8', step: 'PC7', dir: 'PC8', enable: 'PD2', uart: 'PC6', cs: 'PC6', diag: 'PF10' }
                ],
                signaturePins: ['PG13', 'PD4', 'PC7'],
                excludePins: ['PC14', 'PE5', 'PB9'],
                requiredCombos: [{ step: 'PE6', dir: 'PE5' }, { step: 'PG13', dir: 'PG12' }],
                uniqueIdentifiers: ['PG13', 'PD4', 'PC7'],
            }
        };

        let currentBoard = null;
        let parsedConfig = null;
        let lastDetectionResults = null;
        let currentIssues = [];

        function normalizePin(pin) {
            if (!pin) return null;
            return pin.replace(/^[!^]+/, '').replace(/[!^]+$/, '').trim().toUpperCase().replace(/[._]/g, '');
        }

        function getModifiers(pin) {
            if (!pin) return '';
            let mods = '';
            if (pin.includes('!')) mods += '!';
            if (pin.includes('^')) mods += '^';
            return mods;
        }

        function formatPinWithMods(pin) {
            if (!pin) return null;
            const mods = getModifiers(pin);
            const normalized = normalizePin(pin);
            return mods + normalized;
        }

        function isExternalMcu(pin) {
            if (!pin) return false;
            return pin.includes(':');
        }

        function getMcuName(pin) {
            if (!pin || !pin.includes(':')) return 'mcu';
            return pin.split(':')[0].trim();
        }

        function parseKlipperConfig(text) {
            const sections = {};
            const lines = text.split('\n');
            let currentSection = null;
            let currentSectionName = null;

            for (let line of lines) {
                line = line.trim();
                if (!line || line.startsWith('#')) continue;

                const sectionMatch = line.match(/^\[([^\]]+)\]/);
                if (sectionMatch) {
                    currentSectionName = sectionMatch[1].trim();
                    sections[currentSectionName] = {};
                    currentSection = sections[currentSectionName];
                    continue;
                }

                if (currentSection && line.includes(':')) {
                    const idx = line.indexOf(':');
                    const key = line.substring(0, idx).trim();
                    let value = line.substring(idx + 1).trim();
                    const commentIdx = value.indexOf('#');
                    if (commentIdx > -1) value = value.substring(0, commentIdx).trim();
                    currentSection[key] = value;
                }
            }
            return sections;
        }

        function extractPinInfo(sections) {
            const info = {
                stepPins: new Set(),
                dirPins: new Set(),
                enablePins: new Set(),
                uartPins: new Set(),
                csPins: new Set(),
                allPins: new Set(),
                stepDirCombos: [],
            };

            for (const [name, cfg] of Object.entries(sections)) {
                if (!name.includes('stepper') && !name.includes('tmc') && !name.includes('extruder')) continue;

                const stepPin = normalizePin(cfg.step_pin);
                const dirPin = normalizePin(cfg.dir_pin);
                const enablePin = normalizePin(cfg.enable_pin);
                const uartPin = normalizePin(cfg.uart_pin);
                const csPin = normalizePin(cfg.cs_pin);

                // Skip external MCU pins for board detection
                if (stepPin && !isExternalMcu(cfg.step_pin)) {
                    info.stepPins.add(stepPin);
                    info.allPins.add(stepPin);
                }
                if (dirPin && !isExternalMcu(cfg.dir_pin)) {
                    info.dirPins.add(dirPin);
                    info.allPins.add(dirPin);
                }
                if (enablePin && !isExternalMcu(cfg.enable_pin)) {
                    info.enablePins.add(enablePin);
                    info.allPins.add(enablePin);
                }
                if (uartPin && !isExternalMcu(cfg.uart_pin)) {
                    info.uartPins.add(uartPin);
                    info.allPins.add(uartPin);
                }
                if (csPin && !isExternalMcu(cfg.cs_pin)) {
                    info.csPins.add(csPin);
                    info.allPins.add(csPin);
                }

                if (stepPin && dirPin && !isExternalMcu(cfg.step_pin)) {
                    info.stepDirCombos.push({ step: stepPin, dir: dirPin });
                }
            }
            return info;
        }

        function extractAutotuneInfo(sections) {
            const autotune = {};
            for (const [name, cfg] of Object.entries(sections)) {
                const match = name.match(/^autotune_tmc\s+(.+)$/);
                if (match) {
                    const motorName = match[1];
                    autotune[motorName] = {
                        motor: cfg.motor || null,
                        tuningGoal: cfg.tuning_goal || null
                    };
                }
            }
            return autotune;
        }

        function extractSpiInfo(sections) {
            const spiPins = {};
            for (const [name, cfg] of Object.entries(sections)) {
                if (name.startsWith('tmc')) {
                    const sclk = cfg.spi_software_sclk_pin;
                    const mosi = cfg.spi_software_mosi_pin;
                    const miso = cfg.spi_software_miso_pin;
                    if (sclk || mosi || miso) {
                        spiPins[name] = { sclk, mosi, miso };
                    }
                }
            }
            return spiPins;
        }

        function detectBoard(sections) {
            const pinInfo = extractPinInfo(sections);
            const results = [];

            let octopusProVersion = null;
            if (pinInfo.enablePins.has('PA2') && !pinInfo.enablePins.has('PA0')) {
                octopusProVersion = 'v1.1';
            } else if (pinInfo.enablePins.has('PA0') && !pinInfo.enablePins.has('PA2')) {
                octopusProVersion = 'v1.0';
            }

            for (const [boardId, board] of Object.entries(BOARDS)) {
                let score = 0;
                let maxScore = 0;

                if (octopusProVersion) {
                    if (boardId === 'octopus_pro_v1.0' && octopusProVersion === 'v1.1') {
                        results.push({ boardId, score: 0, maxScore: 100, excluded: true });
                        continue;
                    }
                    if (boardId === 'octopus_pro_v1.1' && octopusProVersion === 'v1.0') {
                        results.push({ boardId, score: 0, maxScore: 100, excluded: true });
                        continue;
                    }
                }

                if (board.excludePins) {
                    let hasExcluded = false;
                    for (const exPin of board.excludePins) {
                        if (pinInfo.stepPins.has(normalizePin(exPin))) {
                            hasExcluded = true;
                            break;
                        }
                    }
                    if (hasExcluded) {
                        results.push({ boardId, score: 0, maxScore: 100, excluded: true });
                        continue;
                    }
                }

                if (board.uniqueIdentifiers) {
                    let uniqueMatches = 0;
                    for (const uPin of board.uniqueIdentifiers) {
                        if (pinInfo.stepPins.has(normalizePin(uPin))) uniqueMatches++;
                    }
                    score += (uniqueMatches / board.uniqueIdentifiers.length) * 40;
                    maxScore += 40;
                }

                if (board.requiredCombos) {
                    let comboMatches = 0;
                    for (const combo of board.requiredCombos) {
                        const normalStep = normalizePin(combo.step);
                        const normalDir = normalizePin(combo.dir);
                        for (const configCombo of pinInfo.stepDirCombos) {
                            if (configCombo.step === normalStep && configCombo.dir === normalDir) {
                                comboMatches++;
                                break;
                            }
                        }
                    }
                    score += (comboMatches / board.requiredCombos.length) * 35;
                    maxScore += 35;
                }

                let sigMatches = 0;
                for (const sigPin of board.signaturePins) {
                    if (pinInfo.stepPins.has(normalizePin(sigPin))) sigMatches++;
                }
                score += (sigMatches / board.signaturePins.length) * 25;
                maxScore += 25;

                let totalDriverPins = 0;
                let matchedDriverPins = 0;
                for (const driver of board.drivers) {
                    if (pinInfo.stepPins.has(normalizePin(driver.step))) {
                        totalDriverPins++;
                        matchedDriverPins++;
                        if (pinInfo.dirPins.has(normalizePin(driver.dir))) matchedDriverPins += 0.5;
                        totalDriverPins += 0.5;
                    }
                }
                if (totalDriverPins > 0) score += (matchedDriverPins / totalDriverPins) * 20;
                maxScore += 20;

                const finalScore = maxScore > 0 ? (score / maxScore) * 100 : 0;
                results.push({ boardId, score: finalScore, maxScore: 100 });
            }

            results.sort((a, b) => b.score - a.score);
            lastDetectionResults = results;

            const best = results[0];
            const secondBest = results[1];
            const clearWinner = best.score > 30 && (!secondBest || best.score - secondBest.score > 10);

            return { boardId: best.score > 20 ? best.boardId : null, confidence: best.score / 100, clearWinner, results };
        }

        function renderDetectionDebug(results, selectedId) {
            const container = document.getElementById('detectionDebug');
            const card = document.getElementById('detectionCard');
            card.style.display = 'block';

            let html = '';
            for (const result of results.slice(0, 5)) {
                const isWinner = result.boardId === selectedId;
                const board = BOARDS[result.boardId];
                html += `<div class="detection-score ${isWinner ? 'winner' : ''}">
                    <span class="board-name">${board.name}</span>
                    <span class="score">${result.score.toFixed(1)}%</span>
                </div>`;
            }
            container.innerHTML = html;
        }

        function extractMotors(sections) {
            const motors = [];
            const autotune = extractAutotuneInfo(sections);
            const spiInfo = extractSpiInfo(sections);

            for (const [name, cfg] of Object.entries(sections)) {
                const stepperMatch = name.match(/^stepper_([xyz])(\d*)$/) || name.match(/^(extruder)(\d*)$/);
                if (stepperMatch) {
                    let axis = stepperMatch[1];
                    let num = stepperMatch[2] || '';
                    if (axis === 'extruder') axis = 'e';

                    const isExternal = isExternalMcu(cfg.step_pin);
                    const mcuName = getMcuName(cfg.step_pin);

                    const motor = {
                        name, axis, num,
                        stepPin: normalizePin(cfg.step_pin),
                        dirPin: normalizePin(cfg.dir_pin),
                        enablePin: normalizePin(cfg.enable_pin),
                        stepPinRaw: formatPinWithMods(cfg.step_pin),
                        dirPinRaw: formatPinWithMods(cfg.dir_pin),
                        enablePinRaw: formatPinWithMods(cfg.enable_pin),
                        endstopPin: cfg.endstop_pin || null,
                        isExternal,
                        mcuName,
                        driver: null,
                        driverConfig: {},
                        autotuneMotor: autotune[name]?.motor || null,
                        autotuneTuning: autotune[name]?.tuningGoal || null,
                    };

                    // Find matching TMC config
                    for (const [drvName, drvCfg] of Object.entries(sections)) {
                        if (drvName.match(/^tmc\d+/) && drvName.includes(name)) {
                            const driverType = drvName.split(' ')[0].toUpperCase();
                            motor.driver = driverType;
                            motor.driverConfig = {
                                uartPin: normalizePin(drvCfg.uart_pin),
                                csPin: normalizePin(drvCfg.cs_pin),
                                uartPinRaw: formatPinWithMods(drvCfg.uart_pin),
                                csPinRaw: formatPinWithMods(drvCfg.cs_pin),
                                runCurrent: parseFloat(drvCfg.run_current) || null,
                                senseResistor: parseFloat(drvCfg.sense_resistor) || null,
                                spiPins: spiInfo[drvName] || null,
                            };
                            break;
                        }
                    }

                    motors.push(motor);
                }
            }

            return motors;
        }

        function mapMotorsToSlots(motors, board) {
            const slotMap = new Array(board.driverCount).fill(null);
            const issues = [];
            const externalMotors = [];

            for (const motor of motors) {
                // Handle external MCU motors separately
                if (motor.isExternal) {
                    externalMotors.push(motor);
                    continue;
                }

                let matched = false;
                for (let i = 0; i < board.drivers.length; i++) {
                    const slot = board.drivers[i];
                    if (normalizePin(slot.step) === motor.stepPin) {
                        slotMap[i] = motor;
                        matched = true;

                        // Pin mismatch checks
                        if (motor.dirPin && normalizePin(slot.dir) !== motor.dirPin) {
                            issues.push({
                                type: 'mismatch', motor: motor.name, slot: slot.id, pin: 'dir_pin',
                                expected: slot.dir, found: motor.dirPinRaw,
                                fix: `dir_pin: ${slot.dir}`
                            });
                        }
                        if (motor.enablePin && normalizePin(slot.enable) !== motor.enablePin) {
                            issues.push({
                                type: 'mismatch', motor: motor.name, slot: slot.id, pin: 'enable_pin',
                                expected: slot.enable, found: motor.enablePinRaw,
                                fix: `enable_pin: !${slot.enable}`
                            });
                        }
                        if (motor.driverConfig.uartPin && slot.uart && normalizePin(slot.uart) !== motor.driverConfig.uartPin) {
                            issues.push({
                                type: 'mismatch', motor: motor.name, slot: slot.id, pin: 'uart_pin',
                                expected: slot.uart, found: motor.driverConfig.uartPinRaw,
                                fix: `uart_pin: ${slot.uart}`
                            });
                        }
                        if (motor.driverConfig.csPin && slot.cs && normalizePin(slot.cs) !== motor.driverConfig.csPin) {
                            issues.push({
                                type: 'mismatch', motor: motor.name, slot: slot.id, pin: 'cs_pin',
                                expected: slot.cs, found: motor.driverConfig.csPinRaw,
                                fix: `cs_pin: ${slot.cs}`
                            });
                        }

                        // Sense resistor check
                        if (motor.driver && motor.driverConfig.senseResistor) {
                            const expected = SENSE_RESISTORS[motor.driver];
                            if (expected && Math.abs(motor.driverConfig.senseResistor - expected) > 0.01) {
                                issues.push({
                                    type: 'warning', motor: motor.name,
                                    message: `Sense resistor ${motor.driverConfig.senseResistor}Ω unusual for ${motor.driver} (typical: ${expected}Ω)`
                                });
                            }
                        }

                        // Current check
                        if (motor.driver && motor.driverConfig.runCurrent) {
                            const maxCurrent = MAX_CURRENT[motor.driver];
                            if (maxCurrent && motor.driverConfig.runCurrent > maxCurrent) {
                                issues.push({
                                    type: 'warning', motor: motor.name,
                                    message: `Run current ${motor.driverConfig.runCurrent}A exceeds ${motor.driver} max (${maxCurrent}A)`
                                });
                            }
                        }

                        // TMC driver type validation (UART vs SPI)
                        if (motor.driver) {
                            const usesUart = ['TMC2209', 'TMC2208', 'TMC2225', 'TMC2226'].includes(motor.driver);
                            const usesSpi = ['TMC5160', 'TMC5161', 'TMC2130', 'TMC2160'].includes(motor.driver);

                            if (usesUart && motor.driverConfig.csPin && !motor.driverConfig.uartPin) {
                                issues.push({
                                    type: 'warning', motor: motor.name,
                                    message: `${motor.driver} uses UART, but cs_pin found instead of uart_pin`
                                });
                            }
                            if (usesSpi && motor.driverConfig.uartPin && !motor.driverConfig.csPin) {
                                issues.push({
                                    type: 'warning', motor: motor.name,
                                    message: `${motor.driver} uses SPI, but uart_pin found instead of cs_pin`
                                });
                            }
                        }

                        break;
                    }
                }

                if (!matched) {
                    issues.push({
                        type: 'warning', motor: motor.name, pin: 'step_pin', found: motor.stepPinRaw,
                        message: `Step pin ${motor.stepPinRaw} doesn't match any driver slot`
                    });
                }
            }

            // SPI bus consistency check
            const spiConfigs = motors
                .filter(m => m.driverConfig.spiPins)
                .map(m => ({ motor: m.name, ...m.driverConfig.spiPins }));

            if (spiConfigs.length > 1) {
                const first = spiConfigs[0];
                for (let i = 1; i < spiConfigs.length; i++) {
                    const curr = spiConfigs[i];
                    if (curr.sclk !== first.sclk || curr.mosi !== first.mosi || curr.miso !== first.miso) {
                        issues.push({
                            type: 'info', motor: curr.motor,
                            message: `SPI pins differ from ${first.motor} - verify this is intentional`
                        });
                        break;
                    }
                }
            }

            return { slotMap, issues, externalMotors };
        }

        function copyToClipboard(text, btn) {
            navigator.clipboard.writeText(text).then(() => {
                btn.classList.add('copied');
                btn.textContent = 'Copied';
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.textContent = 'Copy';
                }, 1500);
            });
        }

        function renderBoardViz(board, slotMap, issues, externalMotors) {
            const boardViz = document.getElementById('boardViz');
            const issueSlots = new Set(issues.filter(i => i.type === 'mismatch').map(i => i.slot));

            let html = `<div class="board-outline">
                <div class="board-label">${board.name} · ${board.mcu}</div>
                <div class="driver-slots">`;

            for (let i = 0; i < board.driverCount; i++) {
                const slot = board.drivers[i];
                const motor = slotMap[i];
                const isActive = motor !== null;
                const hasIssue = issueSlots.has(slot.id);

                const checkPin = (configPin, expectedPin) => {
                    if (!configPin) return '';
                    return normalizePin(expectedPin) === configPin ? 'ok' : 'warn';
                };

                const displayStep = motor ? motor.stepPinRaw : slot.step;
                const displayDir = motor ? motor.dirPinRaw : slot.dir;
                const displayEn = motor ? motor.enablePinRaw : slot.enable;
                const displayCs = motor?.driverConfig ? (motor.driverConfig.csPinRaw || motor.driverConfig.uartPinRaw) : (slot.cs || slot.uart);

                // Current display
                let currentHtml = '';
                if (motor?.driverConfig?.runCurrent) {
                    const maxCurr = motor.driver ? MAX_CURRENT[motor.driver] : null;
                    const isHigh = maxCurr && motor.driverConfig.runCurrent > maxCurr * 0.9;
                    currentHtml = `<span class="slot-current ${isHigh ? 'high' : ''}">${motor.driverConfig.runCurrent}A</span>`;
                }

                // Motor info from autotune
                let motorInfoHtml = '';
                if (motor?.autotuneMotor) {
                    motorInfoHtml = `<div class="slot-motor-info" title="${motor.autotuneMotor}">${motor.autotuneMotor}</div>`;
                }

                html += `<div class="driver-slot ${isActive ? 'active' : ''} ${hasIssue ? 'has-issue' : ''}">
                    <div class="slot-header">
                        <span class="slot-id">${slot.id}</span>
                        ${motor?.driver ? `<span class="slot-driver">${motor.driver}</span>` : ''}
                        ${currentHtml}
                    </div>
                    <div class="slot-motor ${motor ? '' : 'empty'}">${motor ? capitalizeMotorName(motor.name) : 'Empty'}</div>
                    ${motorInfoHtml}
                    <div class="slot-pins">
                        <div class="pin-item">
                            <span class="pin-label">STEP</span>
                            <span class="pin-value">${displayStep}</span>
                            ${motor ? `<span class="pin-status ${checkPin(motor.stepPin, slot.step)}"></span>` : ''}
                        </div>
                        <div class="pin-item">
                            <span class="pin-label">DIR</span>
                            <span class="pin-value">${displayDir}</span>
                            ${motor ? `<span class="pin-status ${checkPin(motor.dirPin, slot.dir)}"></span>` : ''}
                        </div>
                        <div class="pin-item">
                            <span class="pin-label">EN</span>
                            <span class="pin-value">${displayEn}</span>
                            ${motor ? `<span class="pin-status ${checkPin(motor.enablePin, slot.enable)}"></span>` : ''}
                        </div>
                        <div class="pin-item">
                            <span class="pin-label">${slot.cs ? 'CS' : 'UART'}</span>
                            <span class="pin-value">${displayCs}</span>
                            ${motor?.driverConfig ? `<span class="pin-status ${checkPin(motor.driverConfig.csPin || motor.driverConfig.uartPin, slot.cs || slot.uart)}"></span>` : ''}
                        </div>
                    </div>
                </div>`;
            }

            html += '</div>';

            // External MCU motors section
            if (externalMotors.length > 0) {
                const mcuGroups = {};
                for (const motor of externalMotors) {
                    if (!mcuGroups[motor.mcuName]) mcuGroups[motor.mcuName] = [];
                    mcuGroups[motor.mcuName].push(motor);
                }

                for (const [mcuName, mcuMotors] of Object.entries(mcuGroups)) {
                    html += `<div class="mcu-section">
                        <div class="mcu-section-label">${mcuName}</div>
                        <div class="external-motors">`;

                    for (const motor of mcuMotors) {
                        let currentHtml = '';
                        if (motor.driverConfig?.runCurrent) {
                            currentHtml = `<span class="slot-current">${motor.driverConfig.runCurrent}A</span>`;
                        }

                        let motorInfoHtml = '';
                        if (motor.autotuneMotor) {
                            motorInfoHtml = `<div class="slot-motor-info">${motor.autotuneMotor}</div>`;
                        }

                        html += `<div class="driver-slot active external-mcu">
                            <div class="slot-header">
                                <span class="slot-id">EXT</span>
                                ${motor.driver ? `<span class="slot-driver">${motor.driver}</span>` : ''}
                                ${currentHtml}
                            </div>
                            <div class="slot-motor">${capitalizeMotorName(motor.name)}</div>
                            ${motorInfoHtml}
                            <div class="slot-pins">
                                <div class="pin-item">
                                    <span class="pin-label">STEP</span>
                                    <span class="pin-value">${motor.stepPinRaw}</span>
                                </div>
                                <div class="pin-item">
                                    <span class="pin-label">DIR</span>
                                    <span class="pin-value">${motor.dirPinRaw}</span>
                                </div>
                            </div>
                        </div>`;
                    }

                    html += '</div></div>';
                }
            }

            html += '</div>';
            boardViz.innerHTML = html;
        }

        function renderIssues(issues, board) {
            const issuesCard = document.getElementById('issuesCard');
            const issuesList = document.getElementById('issuesList');
            const issueCount = document.getElementById('issueCount');
            const exportSection = document.getElementById('exportSection');

            currentIssues = issues;

            if (issues.length === 0) {
                issuesCard.style.display = 'block';
                issueCount.textContent = '';
                issuesList.innerHTML = `<div class="no-issues">All pins match ${board.name}</div>`;
                exportSection.style.display = 'none';
                return;
            }

            issuesCard.style.display = 'block';
            issueCount.textContent = `${issues.length}`;

            const hasFixes = issues.some(i => i.fix);
            exportSection.style.display = hasFixes ? 'block' : 'none';

            let html = '';
            for (const issue of issues) {
                const issueClass = issue.type === 'mismatch' ? '' : (issue.type === 'info' ? 'info' : 'warning');

                if (issue.fix) {
                    html += `<div class="issue-item ${issueClass}">
                        <div class="issue-header">
                            <div>
                                <div class="issue-title">${issue.motor} → ${issue.slot}: ${issue.pin}</div>
                                <div class="issue-detail">Expected ${issue.expected}, found ${issue.found}</div>
                            </div>
                        </div>
                        <div class="issue-fix">
                            <code>${issue.fix}</code>
                            <button class="btn-small btn-copy" onclick="copyToClipboard('${issue.fix}', this)">Copy</button>
                        </div>
                    </div>`;
                } else {
                    html += `<div class="issue-item ${issueClass}">
                        <div class="issue-title">${issue.motor}</div>
                        <div class="issue-detail">${issue.message}</div>
                    </div>`;
                }
            }
            issuesList.innerHTML = html;
        }

        function toggleExport() {
            const textarea = document.getElementById('exportTextarea');
            if (textarea.style.display === 'none') {
                // Generate export text
                const fixes = currentIssues.filter(i => i.fix).map(i => `# ${i.motor} [${i.slot}]\n${i.fix}`);
                textarea.value = fixes.join('\n\n');
                textarea.style.display = 'block';
            } else {
                textarea.style.display = 'none';
            }
        }

        function renderComparisonTable(board, motors, slotMap) {
            const container = document.getElementById('tableContainer');
            const mainMcuMotors = motors.filter(m => !m.isExternal);

            if (mainMcuMotors.length === 0) {
                container.innerHTML = `<div class="empty-state"><p>No motors on main MCU</p></div>`;
                return;
            }

            let html = `<table class="comparison-table">
                <thead><tr><th>Motor</th><th>Slot</th><th>Pin</th><th>Config</th><th>Board</th><th>Status</th></tr></thead>
                <tbody>`;

            for (const motor of mainMcuMotors) {
                let matchedSlot = null;
                for (let i = 0; i < board.drivers.length; i++) {
                    if (normalizePin(board.drivers[i].step) === motor.stepPin) {
                        matchedSlot = board.drivers[i];
                        break;
                    }
                }

                const pins = [
                    { type: 'step', label: 'STEP', config: motor.stepPinRaw, configNorm: motor.stepPin, expected: matchedSlot?.step },
                    { type: 'dir', label: 'DIR', config: motor.dirPinRaw, configNorm: motor.dirPin, expected: matchedSlot?.dir },
                    { type: 'enable', label: 'EN', config: motor.enablePinRaw, configNorm: motor.enablePin, expected: matchedSlot?.enable }
                ];
                if (motor.driverConfig.uartPin) pins.push({ type: 'uart', label: 'UART', config: motor.driverConfig.uartPinRaw, configNorm: motor.driverConfig.uartPin, expected: matchedSlot?.uart });
                if (motor.driverConfig.csPin) pins.push({ type: 'cs', label: 'CS', config: motor.driverConfig.csPinRaw, configNorm: motor.driverConfig.csPin, expected: matchedSlot?.cs });

                for (let i = 0; i < pins.length; i++) {
                    const pin = pins[i];
                    const isMatch = pin.expected && normalizePin(pin.expected) === pin.configNorm;
                    const rowClass = pin.expected && !isMatch ? 'mismatch-row' : '';

                    html += `<tr class="${rowClass}">
                        ${i === 0 ? `<td rowspan="${pins.length}">${motor.name}</td>` : ''}
                        ${i === 0 ? `<td rowspan="${pins.length}">${matchedSlot ? matchedSlot.id : '—'}</td>` : ''}
                        <td><span class="pin-badge">${pin.label}</span></td>
                        <td>${pin.config || '—'}</td>
                        <td>${pin.expected || '—'}</td>
                        <td>${pin.expected ? `<span class="status-chip ${isMatch ? 'match' : 'mismatch'}">${isMatch ? 'OK' : 'MISMATCH'}</span>` : '—'}</td>
                    </tr>`;
                }
            }

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function getEndstopType(pin) {
            if (!pin) return { type: 'none', label: 'None' };
            if (pin.includes('virtual_endstop')) return { type: 'sensorless', label: 'Sensorless' };
            if (pin.includes('probe:')) return { type: 'probe', label: 'Probe' };
            return { type: 'physical', label: formatPinWithMods(pin) };
        }

        function capitalizeMotorName(name) {
            // stepper_x -> Stepper X, stepper_z1 -> Stepper Z1, extruder -> Extruder
            return name
                .split('_')
                .map((part, i) => {
                    if (i === 0) return part.charAt(0).toUpperCase() + part.slice(1);
                    return part.toUpperCase();
                })
                .join(' ');
        }

        function updateStats(motors, slotMap, issues, externalMotors) {
            const statsCard = document.getElementById('statsCard');
            const statsRow = document.getElementById('statsRow');
            const endstopList = document.getElementById('endstopList');

            const mainMotors = motors.filter(m => !m.isExternal);
            const axisCounts = { x: 0, y: 0, z: 0, e: 0 };
            motors.forEach(m => axisCounts[m.axis]++);
            const usedSlots = slotMap.filter(s => s !== null).length;

            // Detect AWD (multiple X or Y motors)
            const isAwd = axisCounts.x > 1 || axisCounts.y > 1;

            let html = `
                <div class="stat-chip"><span class="value">${motors.length}</span> motors</div>
                <div class="stat-chip"><span class="value">${usedSlots}/${currentBoard.driverCount}</span> slots</div>
                <div class="stat-chip"><span class="value">${axisCounts.x}</span> X</div>
                <div class="stat-chip"><span class="value">${axisCounts.y}</span> Y</div>
                <div class="stat-chip"><span class="value">${axisCounts.z}</span> Z</div>
                <div class="stat-chip"><span class="value">${axisCounts.e}</span> E</div>
            `;

            if (isAwd) {
                html += `<div class="stat-chip awd"><span class="value">AWD</span></div>`;
            }

            if (externalMotors.length > 0) {
                html += `<div class="stat-chip"><span class="value">${externalMotors.length}</span> external</div>`;
            }

            const errorCount = issues.filter(i => i.type === 'mismatch').length;
            const warnCount = issues.filter(i => i.type === 'warning').length;
            if (errorCount > 0) {
                html += `<div class="stat-chip"><span class="value" style="color: var(--error)">${errorCount}</span> errors</div>`;
            }
            if (warnCount > 0) {
                html += `<div class="stat-chip"><span class="value" style="color: var(--warning)">${warnCount}</span> warnings</div>`;
            }
            if (errorCount === 0 && warnCount === 0) {
                html += `<div class="stat-chip"><span class="value" style="color: var(--success)">0</span> issues</div>`;
            }

            statsRow.innerHTML = html;

            // Endstop summary
            const endstopLabel = document.getElementById('endstopLabel');
            let endstopHtml = '';
            for (const motor of motors) {
                if (motor.axis === 'e') continue; // Skip extruder
                const endstop = getEndstopType(motor.endstopPin);
                if (endstop.type === 'none' && motor.num) continue; // Skip secondary motors without endstops

                endstopHtml += `<div class="endstop-item">
                    <span class="motor">${capitalizeMotorName(motor.name)}</span>
                    <span class="type ${endstop.type}">${endstop.label}</span>
                </div>`;
            }

            if (endstopHtml) {
                endstopLabel.style.display = 'block';
                endstopList.innerHTML = endstopHtml;
                endstopList.style.display = 'flex';
            } else {
                endstopLabel.style.display = 'none';
                endstopList.style.display = 'none';
            }

            statsCard.style.display = 'block';
        }

        function parseConfig() {
            const text = document.getElementById('configInput').value;
            if (!text.trim()) return;

            const sections = parseKlipperConfig(text);
            const motors = extractMotors(sections);
            if (motors.length === 0) { alert('No stepper motors found.'); return; }

            const boardSelect = document.getElementById('boardSelect');
            let boardId = boardSelect.value;

            if (boardId === 'auto') {
                const detection = detectBoard(sections);
                if (detection.boardId && detection.confidence > 0.2) {
                    boardId = detection.boardId;
                    boardSelect.value = boardId;

                    const badge = document.getElementById('detectedBadge');
                    badge.style.display = 'inline-flex';
                    badge.className = `detected-badge ${detection.clearWinner ? '' : 'low-confidence'}`;
                    document.getElementById('detectedText').textContent = BOARDS[boardId].name.split(' ').slice(-2).join(' ');
                    renderDetectionDebug(detection.results, boardId);
                } else {
                    alert('Could not detect board. Please select manually.');
                    if (detection.results) renderDetectionDebug(detection.results, null);
                    return;
                }
            } else {
                document.getElementById('detectionCard').style.display = 'none';
            }

            currentBoard = BOARDS[boardId];
            parsedConfig = { sections, motors };

            const { slotMap, issues, externalMotors } = mapMotorsToSlots(motors, currentBoard);

            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('boardViz').style.display = 'block';
            document.getElementById('vizTitle').textContent = currentBoard.name;

            renderBoardViz(currentBoard, slotMap, issues, externalMotors);
            renderIssues(issues, currentBoard);
            renderComparisonTable(currentBoard, motors, slotMap);
            updateStats(motors, slotMap, issues, externalMotors);
        }

        function onBoardChange() {
            document.getElementById('detectedBadge').style.display = 'none';
            document.getElementById('detectionCard').style.display = 'none';

            if (parsedConfig && document.getElementById('boardSelect').value !== 'auto') {
                currentBoard = BOARDS[document.getElementById('boardSelect').value];
                const { slotMap, issues, externalMotors } = mapMotorsToSlots(parsedConfig.motors, currentBoard);

                document.getElementById('vizTitle').textContent = currentBoard.name;
                renderBoardViz(currentBoard, slotMap, issues, externalMotors);
                renderIssues(issues, currentBoard);
                renderComparisonTable(currentBoard, parsedConfig.motors, slotMap);
                updateStats(parsedConfig.motors, slotMap, issues, externalMotors);
            }
        }

        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabId + 'Tab').classList.add('active');
        }

        function clearAll() {
            document.getElementById('configInput').value = '';
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('boardViz').style.display = 'none';
            document.getElementById('statsCard').style.display = 'none';
            document.getElementById('issuesCard').style.display = 'none';
            document.getElementById('detectionCard').style.display = 'none';
            document.getElementById('boardSelect').value = 'auto';
            document.getElementById('detectedBadge').style.display = 'none';
            document.getElementById('tableContainer').innerHTML = `<div class="empty-state"><p>No data</p></div>`;
            document.getElementById('exportTextarea').style.display = 'none';
            currentBoard = null;
            parsedConfig = null;
            lastDetectionResults = null;
            currentIssues = [];
        }
    </script>
</body>
</html>